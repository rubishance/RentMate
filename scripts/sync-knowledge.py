import os
import re

# Paths
PAGES_DIR = r"c:\AnitiGravity Projects\RentMate\src\pages"
COMPONENTS_DIR = r"c:\AnitiGravity Projects\RentMate\src\components"
MIGRATIONS_DIR = r"c:\AnitiGravity Projects\RentMate\supabase\migrations"
KNOWLEDGE_FILE = r"c:\AnitiGravity Projects\RentMate\supabase\functions\chat-support\knowledge.ts"
OUTPUT_MD = r"c:\AnitiGravity Projects\RentMate\AI_MASTER_KNOWLEDGE.md"

def get_pages():
    pages = []
    for item in os.listdir(PAGES_DIR):
        if item.endswith((".tsx", ".ts")):
            pages.append(item.replace(".tsx", "").replace(".ts", ""))
    return sorted(pages)

def get_major_components():
    # Only pick components that look like features/widgets
    components = []
    for root, dirs, files in os.walk(COMPONENTS_DIR):
        for file in files:
            if file.endswith((".tsx")) and any(x in file for x in ["Widget", "Card", "Modal", "Calculator", "Manager", "Tracker"]):
                components.append(file.replace(".tsx", ""))
    return sorted(list(set(components)))

def get_data_schema():
    # Scrape table names from migration files
    tables = set()
    table_pattern = re.compile(r"CREATE TABLE (?:IF NOT EXISTS )?(\w+)", re.IGNORECASE)
    
    for file in os.listdir(MIGRATIONS_DIR):
        if file.endswith(".sql"):
            with open(os.path.join(MIGRATIONS_DIR, file), 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                matches = table_pattern.findall(content)
                for table in matches:
                    if table not in ["auth", "public"]:
                        tables.add(table)
    return sorted(list(tables))

def generate_knowledge():
    pages = get_pages()
    components = get_major_components()
    tables = get_data_schema()
    
    context = "## DYNAMIC APP CONTEXT (Generated)\n\n"
    context += "### Current Routes/Pages:\n"
    for p in pages: context += f"- {p}\n"
    
    context += "\n### Active Components & Features:\n"
    for c in components: context += f"- {c}\n"
    
    context += "\n### Database Schema (Entities Renty can query):\n"
    for t in tables: context += f"- {t}\n"
    
    return context

def update_knowledge_ts(context):
    with open(KNOWLEDGE_FILE, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Replace or append dynamic context
    marker_start = "// DYNAMIC_CONTEXT_START"
    marker_end = "// DYNAMIC_CONTEXT_END"
    
    new_context_code = f"{marker_start}\nexport const DYNAMIC_APP_CONTEXT = `{context}`;\n{marker_end}"
    
    if marker_start in content and marker_end in content:
        pattern = re.compile(rf"{marker_start}.*?{marker_end}", re.DOTALL)
        content = pattern.sub(new_context_code, content)
    else:
        content += f"\n\n{new_context_code}"
    
    with open(KNOWLEDGE_FILE, 'w', encoding='utf-8') as f:
        f.write(content)

def generate_master_md(context):
    # Read existing knowledge to combine
    with open(KNOWLEDGE_FILE, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Simple extraction of the main knowledge strings (approximate)
    he_match = re.search(r"export const KNOWLEDGE_HE = `(.*?)`;", content, re.DOTALL)
    en_match = re.search(r"export const KNOWLEDGE_EN = `(.*?)`;", content, re.DOTALL)
    
    master_content = "# RENTY MASTER KNOWLEDGE (AUTO-SYNCED)\n\n"
    master_content += "> [!NOTE]\n"
    master_content += "> This file is automatically generated by `scripts/sync-knowledge.py`.\n"
    master_content += "> Upload this file to NotebookLM to provide Renty with full app context.\n\n"
    
    master_content += context + "\n\n"
    
    if he_match:
        master_content += "## Hebrew Knowledge Base\n" + he_match.group(1) + "\n\n"
    if en_match:
        master_content += "## English Knowledge Base\n" + en_match.group(1) + "\n\n"
        
    with open(OUTPUT_MD, 'w', encoding='utf-8') as f:
        f.write(master_content)

if __name__ == "__main__":
    print("ðŸš€ Starting AI Knowledge Sync...")
    ctx = generate_knowledge()
    update_knowledge_ts(ctx)
    generate_master_md(ctx)
    print(f"âœ… Sync complete! Updated {KNOWLEDGE_FILE} and generated {OUTPUT_MD}")
